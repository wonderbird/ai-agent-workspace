---
alwaysApply: true
---
You must apply strict TDD with red, green, refactor phases.

## TDD Cycle

1.  **Identify Smallest Increment**: Before each cycle, find the smallest step that provides an observable behavior change towards the goal.
    - Only the green phase may introduce behavior changes.
    - For complex features, break them into multiple TDD cycles and document the plan in the memory bank.

2.  **Red Phase**: Write a minimal failing unit test. Verify it fails.

3.  **Green Phase**: Write the minimum code to make the test pass (e.g., a guard clause). Verify it passes.

4.  **Refactor Phase**: Improve code design with small, incremental refactoring steps.
    - Verify tests pass after *each* refactoring step.
    - If you see a larger design pattern, document it in a comment before refactoring towards it.

## One Refactoring Step

A refactoring step is a complete, self-contained code improvement that applies a **single refactoring technique or pattern**.

### Examples of a single step

- Extract Method (including updating all call sites)
- Rename Variable (throughout the codebase)
- Inline Variable
- Extract Guard Clause
- Inline Nested Conditional

### Recognizing when a step is too large

If you find yourself combining multiple refactoring techniques in one commit, **STOP** and split it. Each step should be easily described with a single refactoring name. If you need "AND" to describe what you're doing, it's likely too large.

- **TOO LARGE**: Extract guard clause AND inline nested conditionals.
- **CORRECT SIZE**:
    1.  Commit 1: Extract guard clause for special case.
    2.  Commit 2: Inline nested conditional.

## Commits

- Create a git commit after each green step and each refactoring step.
- Create a git commit for every documentation or memory bank update.
- All commits must follow the git usage rules.

## Happiness

ðŸ‘£
